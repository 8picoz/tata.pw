---
title: RustでDXRを使ってレイトレした話[WIP]
---

(この記事は間に合わなかったので書き途中です)  

この記事は[レイトレアドカレ](https://qiita.com/advent-calendar/2021/raytracing)22日の記事です。

今回作成したプロジェクトのリポジトリは[こちら](https://github.com/8picoz/rwr)です。

# windows-rsとwinapi-rs
現在、RustでWindows APIを使いたい場合、有名なcrateが２つ存在して一つは[windows-rs](https://github.com/microsoft/windows-rs)、もう一つは[winapi-rs](https://github.com/retep998/winapi-rs)です。

[winapi-rs](https://github.com/retep998/winapi-rs)は完全に人の手で管理されている第三者のプロジェクトであり、こちらは自分が軽く調べてみたところDXRのサポートはあまり活発には[行っていなさそう](https://github.com/retep998/winapi-rs/pull/812)でした。


[windows-rs](https://github.com/microsoft/windows-rs)はマイクロソフトが公式で提供しているもので、[win32metadata](https://forest.watch.impress.co.jp/docs/news/1301910.html)を利用して自動的にapiを生成するcrate<sup>[[1]](https://blogs.windows.com/windowsdeveloper/2021/01/21/making-win32-apis-more-accessible-to-more-languages/)</sup>です。
こちらのプロジェクトはDXRに使用される構造体などが定義されてそうに見え、さらにComPtrなどでCOMオブジェクトを管理する場合、Rust上で行うとうまくライフタイムが管理してくれるという情報を見ました。

以上の理由から自分の場合は[windows-rs](https://github.com/microsoft/windows-rs)を採用しました。  

結論から言うと今回の場合は特にapiなどが足りないなどの問題はありませんでした。もっと更に深く触ろうとなるとサポート外の構造体などが必要になるかもしれません。  

Cargo.tomlはこのように設定しています
```
[package]
name = "rwr"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

[dependencies.windows]
version = "0.29.0"
features = [
    "alloc",
    "Win32_Foundation",
    "Win32_Graphics_Direct3D_Fxc",
    "Win32_Graphics_Direct3D12",
    "Win32_Graphics_Dxgi_Common",
    "Win32_Graphics_Gdi",
    "Win32_Security",
    "Win32_System_LibraryLoader",
    "Win32_System_Threading",
    "Win32_System_WindowsProgramming",
    "Win32_UI_WindowsAndMessaging",
]

[dependencies.windows-sys]
version = "0.29.0"
features = [
    "Win32_Foundation",
    "Win32_Security",
    "Win32_System_Threading",
    "Win32_UI_WindowsAndMessaging",
]
```

# HLSLのコンパイル
Visual Studio上でそのままHLSLを書くとビルド時に自動でコンパイルをしてくれるのですが、そのような機能は今回の環境ではないので自前でコンパイルしなくてはいけません。  
そのためにはHLSLコンパイラの[fxc](https://docs.microsoft.com/ja-jp/cpp/build/reference/hlsl-property-pages?view=msvc-170)か[dxc]()を使用するのですがfxcはレイトレーシング用のシェーダーに対応しておらずdxcはDirectX12から出てきた新しいコンパイラなのでこちらを採用します。  

dxcはdxcompiler.dllとdxil.dllをdxcバイナリと同一のフォルダ内に置くことで使用できます。  

今回は以下のようにコンパイルオプションを指定してコンパイルしました。  
`dxc -T lib_6_4 "./ray_shader.hlsl" -Fo ./ray_shader.cso`

# DXRのセットアップの流れについて

ここはD3D12全体のセットアップの流れではなく、DXRのセットアップのみを抽出した流れです。

- 頂点バッファの作成
- BLASとTLASの生成
  - Acceleration Structure
    - コレに関しては[こちら](https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-geometry-interaction-diagram)がわかりやすいです
- グローバルルートシグネチャとローカルルートシグネチャを作成
  - グローバルルートシグニチャ
    - レイトレーシングパイプライン全体で使用されるもの
  - ローカルシグニチャ
    - 各シェーダー個別で使われるもの
  - 今回は個別にシグネチャを設定することがないのでグローバルルートシグニチャのみ
- 専用シェーダーの読み込み
  - RayGeneration
    - レイを生成するためのシェーダー
  - Intersection
    - BLASのAABBと交差したときに呼び出されるシェーダー
    - この中で内部のジオメトリとの交差判定を行う、三角形の場合はデフォルトのものを使用すれば良い
  - AnyHit
    - レイがジオメトリと交差する毎に呼び出されるシェーダー
  - ClosestHit
    - レイがシーンのオブジェクトにあたったときに一番近くで交差したもので呼び出されるシェーダー
  - Miss
    - レイがシーンのオブジェクトに当たらなかった場合に呼び出されるシェーダー
  - Callable
    - ほかシェーダーから呼び出し可能なシェーダー
- StateObjectの生成
  - ヒットグループ生成
  - Subobjectを生成する
    - Subobjectはグローバルルートシグニチャやレイトレーシング用シェーダーやヒットグループなどの設定関係のものがまとめて関連付けられたもの
      ```rust
      let mut sub_objs = vec![

          D3D12_STATE_SUBOBJECT {
              Type: D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE,
              pDesc: &mut global_root_signature as *mut _ as _,
          },
          D3D12_STATE_SUBOBJECT {
              Type: D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG,
              pDesc: &mut shader_config as *mut _ as _,
          },
          D3D12_STATE_SUBOBJECT {
              Type: D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG,
              pDesc: &mut pipeline_config as *mut _ as _,
          },
          D3D12_STATE_SUBOBJECT {
              Type: D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY,
              pDesc: &mut dxil_lib_desc as *mut _ as _,
          },
          D3D12_STATE_SUBOBJECT {
              Type: D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP,
              pDesc: &mut hit_group_desc as *mut _ as _,
          },

      ];
      ```
    - レイトレ中のデプスの設定などを行う
- 結果を書き出すバッファの作成
  - UNORDERED_ACCESSを許可した状態でバッファを作成します
- シェーダーテーブルの作成
  - レイトレを行う上でのすべてのシェーダーの情報が乗ったもの
- 設定したこれらをコマンドリストに乗せてレンダリング
  

以下は実際に上の流れをまとめたものです。
```rust
pub fn init_dxr(&mut self) -> Result<()> {

    let tri = [
        Vertex::new(-0.5, -0.5, 0.0),
        Vertex::new(0.5, -0.5, 0.0),
        Vertex::new(0.0, 0.75, 0.0),
    ];

    self.dx.create_vertex_buffer(tri)?;
    self.dx.build_blas()?;
    self.dx.build_tlas()?;
    self.dx.create_global_root_signature()?;
    self.dx.create_state_object()?;
    self.dx.create_result_resource()?;
    self.dx.create_shader_table()?;

    Ok(())
}
```

## こまったところ
DXGI_FORMAT_B8G8R8A8_UNORMとDXGI_FORMAT_R8G8B8A8_UNORMが違うことに気づかなかった

# Rust特有の点
## 引数のNoneかstd::ptr::null()について
```rust
unsafe { CreateEventA(std::ptr::null(), false, false, None) }
```
このようにC++上では`std::ptr::null()`と`None`の部分がどちらもポインタなのですが、windows-rs上だと別れていることがあります。
あくまで予想でしかないのですが、ここの使い分けは生ポインタの方は元々read/writeを目的としたポインタだったもので、Optionの方はreadを目的としたポインタだったものを分けているのではないかと思っています。


## メンバにOptionとしてdeviceなどが載ってるので毎回取得してくるのにunwrapをしなければ行けない  
自分が作ったような構造だと
```rust
let device = self.device.as_ref().expect("You have to initialize a device");
let command_list = &self.command_list.as_ref().expect("You have to initialize a command list")[self.frame_index as usize];
let command_allocator = &self.command_allocator.as_ref().expect("You have to initialize a command allocator")[self.frame_index as usize];
let command_queue = self.command_queue.as_ref().expect("You have to initialize a command queue");
let global_root_signature = self.global_root_signature.as_ref().expect("You have to initialize a global root signature");
let tlas_descriptor = self.tlas_descriptor.as_ref().expect("You have to initialize a tlas descriptor");
let result_resource_descriptor = self.result_resource_descriptor.as_ref().expect("You have to initialize a result resource discriptor");
let state_object = self.state_object.as_ref().expect("You have to initialize a state object");
let result_buffer = self.result_buffer.as_ref().expect("You have to initialize a result buffer");
```
このような感じに関数毎に必要なフィールドの変数をunwrapして取ってこなければ行けなく、めちゃくちゃめんどくさいです。  
対策として`Dx12::new()`の部分でこれらすべての初期化を行って最初からすべてのフィールドの変数が入った状態で返せばこれはなくなる気がしますが、それはそれで処理を分割できなくなり、肥大化しそうなので今の所やってはいません  
(他に良い設計方法があるのならば教えてほしいです…)  


## rust-analyzerがものすごくメモリを持っていく
![task_manager](https://i.imgur.com/Eg84ouc.png)  
windows-rsが大きすぎるせいか、ものすごくメモリを持っていかれます。  
補完もあまり挙動が安定していなく、サジェストが出てくるのがとても遅かったりそもそも構造体などの名前がサジェストに出てこなかったりします。  
![coding](https://i.imgur.com/Rsl64sC.gif)  
rust-analyzerを諦めてrlsで書くと解決する気がします。


## Blobの作成
シェーダーなどを読み込んだり、ルートシグニチャをシリアライズするときに使用するBlobの作成方法がC++だと
```C++
ComPtr<ID3DBlob> pBlob;
ComPtr<ID3DBlob> pErrorBlob;

auto hr = D3D12SerializeRootSignature(
  &desc,
  D3D_ROOT_SIGNATURE_VERSION_1_0,
  pBlob.GetAddressOf(),
  pErrorBlob.GetAddressOf()
);
```
のように初期値を設定せずに作成することはRustでは出来ないので、適当な構造体を入れた値を入れて作ろうとしましたが、定義的には
```rust
pub struct ID3DBlob(::windows::core::IUnknown);
impl ID3DBlob {
    #[doc = "*Required features: 'Win32_Graphics_Direct3D'*"]
    pub unsafe fn GetBufferPointer(&self) -> *mut ::core::ffi::c_void {
        ::core::mem::transmute((::windows::core::Interface::vtable(self).3)(::core::mem::transmute_copy(self)))
    }
    //...
```
のようになっていて構造体のフィールドの変数(ID3DBlob::0)にIUnknownを渡さなければ行けなく、これはトレイトオブジェクトとなっていて実際に何を渡してあげれば良いかが自分はわからなかったので他の手段を取ることにしました。  
結果的に
```rust
let mut blob: Option<ID3DBlob> = Some(D3DCreateBlob(2048)?);
let mut err_blob: Option<ID3DBlob> = Some(D3DCreateBlob(2048)?);
```
のようにすることで解決しました。


ビルド時に成果物が生成される場所に自動でshadersもコピーするように作りたい  
D3D12_EXPORT_DESCを作るときにワイド文字列として渡すためにUTF-16にしてVec<u16>として集めて*mut Vec<u16>を渡さなければいけない  
as *mut _ as _のように生のポインタを渡さないといけないのか&mutのように可変参照だけで良いのかの判別が引数などのメタデータからわかりにくい  
c_void系の引数は*mut _のようにRust上の生ポインタに変換してからas *mut c_voidで変換をする 例: &mut hit_group_desc as *mut D3D12_HIT_GROUP_DESC as *mut c_void  
windows-rsが大きすぎるからか、rust-analyzerで補完がうまく効かない(rlsでは試していない)  
shader configなどでXMFLOAT3の大きさを指定するところがあるがstd::mem::size_of::<[f32; 3]>()のように指定した  
殆どのapiがT: Interfaceとして返してくるので型を書かなければならないときが多い  
基本ポインタを渡し合うので使用されるまで生存していなければいけいないときが多く、その場合はフィールドの変数などで保持しなければならない?  
&'static strからencode_utf16()を使用して&[u16]に変換してPWSTRとして使用するときにnull文字を入れないとダメ  
HRESULTについて  
当たり前だけど誰もやっている人がいないので、便利ヘッダなどがない。  

#まだやりたいところ
dx12.rs内でdeviceなどの必要なフィールドの変数をexceptでunwrapしているところを伝搬してpanicさせるかどうかを考える

# 実際にレイトレして画像を出してみる
[WIP]

# 感想
RustではResultがあるので、D3D12CreateDeviceなどの引数にポインタを渡して成功か失敗かを見るようなHRESULTが返ってくる設計はすべてResultで包まれていて良いなと感じました。(これはあとで書き直す)  
CreateSwapChainなどはちゃんとResultに包まれてたが通常のCppで書く場合と同様に生ポインタを渡す必要がある場合があり、これはCreateWindowExAのように返り値が基本hwndでlpparamにポインタとして渡す必要があったり、CheckFeatureSupportのようにその関数自体の失敗とその機能のサポートをしてないよという意味合いの失敗はごっちゃになったりするのでResultで包まれていない？  
QueryInterface()ではなくIDXGISwapChainなどが内部にIUnknownという名前のInterfaceというトレイトを実装した構造体を保持していてそのIUnknownがvtableをもっていてそれがInterfaceの持つcast()というメソッドによりQueryInterfaceと同等の事ができるようになる  
次回はこのリポジトリを元にパストレだったりGGXだったりをGPUで実装しようかなと思っていて、このRust + DXRの記事もこれからいくつか書こうかなと思っています。
あ、あとVulkan/VKRも触ってみたいですね。

# 参考文献
[Two Shader Compilers of Direct3D 12](https://asawicki.info/news_1719_two_shader_compilers_of_direct3d_12)  
[Direct3D 12を始める – Command | shobomalog](https://shobomaru.wordpress.com/2015/04/20/d3d12-command/)  
[DirectX-Headers/d3dx12.h at main · microsoft/DirectX-Headers](https://github.com/microsoft/DirectX-Headers/blob/main/include/directx/d3dx12.h)  
[Direct3D12のデバッグを助けるID3D12Object::SetName: 新 masafumi's Diary](http://masafumi.cocolog-nifty.com/masafumis_diary/2016/02/direct3d12-601f.html)  
[Device Removalの処方箋 - 補足資料 | shikihuiku – 色不異空 – Real-time rendering topics in Japanese.](https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/)  
[microsoft/DirectX-Graphics-Samples: This repo contains the DirectX Graphics samples that demonstrate how to build graphics intensive applications on Windows.](https://github.com/microsoft/DirectX-Graphics-Samples)  
[windows-samples-rs/main.rs at master · microsoft/windows-samples-rs](https://github.com/microsoft/windows-samples-rs/blob/master/direct3d12/src/main.rs)  
[DirectX-Headers/d3dx12.h at main · microsoft/DirectX-Headers](https://github.com/microsoft/DirectX-Headers/blob/main/include/directx/d3dx12.h)  